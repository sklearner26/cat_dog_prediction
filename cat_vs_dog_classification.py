# -*- coding: utf-8 -*-
"""cat-vs-dog-classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MMoUGUPZ0kgu-ue8EoHRAP1tG5lLYceR
"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

"""!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
"""

! chmod 600 ~/.content/kaggle.json/

!kaggle datasets download -d tongpython/cat-and-dog

import zipfile
zip_ref=zipfile.ZipFile('/content/cat-and-dog.zip','r')
zip_ref.extractall('/content')
zip_ref.close()

import numpy as np
from numpy import random as rd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import save_model
from keras import Sequential
from keras.layers import Dense,Conv2D,MaxPooling2D,Flatten

#Making generator for training set
train_ds=keras.utils.image_dataset_from_directory(
    directory='/content/training_set/training_set',
    labels='inferred',
    label_mode='int',
    batch_size=32,
    image_size=(256,256)#Due to different size of every image
)

#Making generator for testing set
validation_ds=keras.utils.image_dataset_from_directory(
    directory='/content/test_set/test_set',
    labels='inferred',
    label_mode='int',
    batch_size=32,
    image_size=(256,256)#Due to different size of every image
)
'''
test_ds=keras.utils.image_dataset_from_directory(
    directory='/content/test_set',
    labels='inferred',
    label_mode='int',
    batch_size=32,
    image_size=(256,256)#Due to different size of every image
)
'''

train_show=train_ds

#tf.experimental.numpy.experimental_enable_numpy_behavior()
image = train_show.take(1).get_single_element()[0][1]
image=image.numpy()
image = image.astype(np.uint8)
type(image)
plt.imshow(image)
plt.show()
'''
print(train_show.take(1).get_single_element()[0][1])
plt.imshow(round(train_show.take(1).get_single_element()[0][1]),ndigit=0)
plt.show()
'''

#print(type(train_ds))
for element in train_show.take(1):
    print(element[0].shape)
    print(type(element))
# Convert the elements of the train_ds dataset to float32
train_show = train_show.map(lambda x, y: (tf.cast(x, tf.uint8), y))

# Plot the first image in the train_ds dataset
plt.imshow(train_show.take(1).get_single_element()[0][1])
plt.show()
print(train_show.take(1).get_single_element()[0][1])

#normalize to 0 to 1
def process(image,label):
  image=tf.cast(image/255. ,tf.float32)
  return image,label
train_ds=train_ds.map(process)
validation_ds=validation_ds.map(process)



#create cnn model
model=Sequential()
model.add(Conv2D(32,kernel_size=(3,3),padding='valid',activation='relu',input_shape=(256,256,3))) #convulation layer1
model.add(MaxPooling2D(pool_size=(2,2),strides=2,padding='valid')) #pooling layer1

model.add(Conv2D(64,kernel_size=(3,3),padding='valid',activation='relu')) #convulation layer2
model.add(MaxPooling2D(pool_size=(2,2),strides=2,padding='valid')) #pooling layer2

model.add(Conv2D(128,kernel_size=(3,3),padding='valid',activation='relu')) #convulation layer3
model.add(MaxPooling2D(pool_size=(2,2),strides=2,padding='valid')) #pooling layer3

model.add(Flatten())
model.add(Dense(128,activation='relu'))#Fully connected layer
model.add(Dense(64,activation='relu'))#Fully connected layer
model.add(Dense(1,activation='sigmoid'))#output layer

model.summary()

model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])

history=model.fit(train_ds,epochs=5,validation_data=validation_ds)

save_model(model, "cnn_final_model.h5")

import matplotlib.pyplot as plt

plt.plot(history.history['accuracy'],color='red',label='train')
plt.plot(history.history['val_accuracy'],color='blue',label='validation')
plt.legend()
plt.show()

plt.plot(history.history['loss'],color='red',label='train')
plt.plot(history.history['val_loss'],color='blue',label='validation')
plt.legend()
plt.show()

import cv2

cat_image=cv2.imread('/content/cat_image.png')
dog_image=cv2.imread('/content/dog.jpg')

plt.imshow(cat_image)
plt.imshow(dog_image)



cat_image.shape,dog_image.shape

#resize test image
cat_img=cv2.resize(cat_image,(256,256))
dog_img=cv2.resize(dog_image,(256,256))

#here due to one image assign batch size equal to 1
cat=cat_img.reshape((1,256,256,3))
dog=dog_img.reshape((1,256,256,3))

pred1=model.predict(cat)
pred2=model.predict(dog)

pred1,pred2